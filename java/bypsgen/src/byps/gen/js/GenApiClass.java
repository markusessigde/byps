package byps.gen.js;
/* USE THIS FILE ACCORDING TO THE COPYRIGHT RULES IN LICENSE.TXT WHICH IS PART OF THE SOURCE CODE PACKAGE */
import java.io.IOException;
import java.util.ArrayList;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import byps.BRegistry;
import byps.gen.api.MemberInfo;
import byps.gen.api.SerialInfo;
import byps.gen.utils.CodePrinter;

class GenApiClass {
	
	static Log log = LogFactory.getLog(GenApiClass.class);
	
	static void generate(CustomControl fact, PrintContext pctxt, SerialInfo serInfo) throws IOException {
		log.debug("generate(" + serInfo);
		if (serInfo.isCollectionType()) {
			// No API class for List<>...
		}
		else if (serInfo.isArrayType()) {
			// No API class for int[]...
		}
		else if (serInfo.isStubType()) {
			// Stub API class is generated by GenRemoteStub
		}
		else if (serInfo.typeId < pctxt.classDB.getRegistry().getMinTypeIdUser()){
			// No API class for RemoteException ...
		}
		else if (serInfo.isResultClass() || serInfo.isRequestClass()) {
			// JSON API does not need a class for results or requests 
		}
		else  {
			log.info("Generate API class for type " + serInfo.typeId + ": " + serInfo);
			CodePrinter pr = pctxt.getPrinter();
			fact.createGenApiClass(pctxt, serInfo, pr).generate();
			pr.close();
		}
		log.debug(")generate");
	}
	
	protected GenApiClass(PrintContext pctxt, SerialInfo serInfo, CodePrinter pr) {
		this.pctxt = pctxt;
		this.serInfo = serInfo;
		this.pr = pr;
	}
	
	private void generateClassForValues(ArrayList<MemberInfo> members) throws IOException {
		log.debug("generateClassForValues(");

		pctxt.printComments(pr, serInfo.comments);

		CodePrinter mpr = pr.print(serInfo.pack).print(".").print(serInfo.name).print(" = function(");

		boolean first = true;
		for (MemberInfo minfo : members) {
      if (PrintHelper.isIgnoreMember(minfo)) continue;
			if (!first) mpr.print(", "); else first = false; 
		  mpr.print(minfo.name);
		}
		mpr.println(") {");

		pr.beginBlock();
		
		pr.print(serInfo.isInline ? "// " : "").print("this._typeId = ").print(serInfo.typeId).println(";");
		
		for (MemberInfo minfo : members) {
      if (PrintHelper.isIgnoreMember(minfo)) continue;
			pr.print("this.").print(minfo.name).print(" = ")
			  .print(minfo.name).print(" || ").print(getDefaultValueForType(minfo.type.typeId)).println(";");
		}

		pr.endBlock();
		
		pr.println("};");
		
		pr.println();
		
		log.debug(")generateClassForValues");
	}
	
	private String getDefaultValueForType(int typeId) {
		switch (typeId) {
		
		case BRegistry.TYPEID_BOOL: return "false"; 
		
		case BRegistry.TYPEID_WCHAR: return "\'\'"; 
		
		case BRegistry.TYPEID_INT8: 
		case BRegistry.TYPEID_INT16: 
		case BRegistry.TYPEID_INT32: 
		case BRegistry.TYPEID_FLOAT: 
		case BRegistry.TYPEID_DOUBLE: return "0";
		
		case BRegistry.TYPEID_INT64: return "\'0.\'";
		
		case BRegistry.TYPEID_STRING: return "\"\"";
		
		default: return "null";
		}
	}

	private void generate() throws IOException {
		log.debug("generate");

		// Separate constant members from normal members  
		ArrayList<MemberInfo> valueMembers = new ArrayList<MemberInfo>();
		ArrayList<MemberInfo> constMembers = new ArrayList<MemberInfo>();
		PrintHelper.collectAllMembers(serInfo, valueMembers, constMembers);

		generateClassForValues(valueMembers);
		pr.println();
		
		log.debug(")generate");
	}


	private final SerialInfo serInfo;
	private final CodePrinter pr;
	private final PrintContext pctxt;
}
